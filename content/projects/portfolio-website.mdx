---
name: "vivekmahendra.com"
description: "Personal website with markdown-based content and interactive visualizations"
link: "https://github.com/vivekmahendra/personal-website"
date: "2024-03-15"
technologies:
  [
    "typescript",
    "react",
    "react-router",
    "tailwindcss",
    "mdx",
    "visx",
    "d3",
    "Cloud Run",
  ]
---

# Personal Portfolio Website

This is my personal portfolio website built with modern web technologies, focusing on performance, maintainability, and clean design. The site serves as both a showcase of my work and a platform for sharing ideas through a built-in blog.

## Architecture Overview

The application is built on <ShinyLink href="https://reactrouter.com">React Router v7</ShinyLink> (the evolution of Remix), providing full-stack capabilities with file-based routing and server-side rendering. The content management system uses <ShinyLink href="https://mdxjs.com">MDX</ShinyLink> files for blog posts and project descriptions, allowing for rich content with embedded React components.

The design philosophy emphasizes minimalism and performance:

- Clean, professional typography using system fonts
- <ShinyLink href="https://tailwindcss.com">Tailwind CSS</ShinyLink> for
  consistent, utility-first styling
- Subtle animations that enhance UX without being distracting
- Mobile-first responsive design
- Fast build times and optimal loading performance

## Key Technical Features

### Content-First Architecture

All blog posts and project descriptions are written in MDX, stored in the `/content` directory. This approach provides the best of both worlds: the simplicity of Markdown with the power of React components for interactive elements like charts and code snippets.

### Component Organization

The codebase follows a clear component hierarchy:

- `/layouts` - Reusable layout components
- `/home` - Home page specific sections
- `/ui` - General UI components
- `/mdx` - Components designed for use within MDX content
- `/react-bits` - Third-party animated components

### Performance Optimizations

- <ShinyLink href="https://vitejs.dev">Vite</ShinyLink> for fast development and
  optimized production builds
- Dynamic imports for code splitting
- Responsive images and lazy loading
- Minimal JavaScript bundle size

**Core Implementation Examples**:

<CodeSnippet title="React Router v7 Layout Structure" filename="Layout.tsx">
{`// Main app layout with mobile-responsive navigation
export function Layout({ children }: { children: React.ReactNode }) {
  const location = useLocation();
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false);

return (

<div className="min-h-screen bg-white text-black flex flex-col">
<header className="border-b border-gray-200">
{/* Desktop Navigation */}
<nav className="hidden md:flex space-x-8">
{navigation.map((item) => (
<Link
to={item.href}
className={\`transition-colors \${
location.pathname === item.href
? "text-black"
: "text-gray-500 hover:text-black"
}\`} >
{item.name}
</Link>
))}
</nav>

        {/* Animated mobile menu with staggered transitions */}
        <div className={\`md:hidden overflow-hidden transition-all duration-300 \${
          mobileMenuOpen ? 'max-h-96 opacity-100' : 'max-h-0 opacity-0'
        }\`}>
          {/* Menu items with cascading animation delays */}
        </div>
      </header>

      <main className="flex-grow">{children}</main>
      <footer className="border-t border-gray-200 mt-auto">
        Made in Phoenix ðŸŒµ
      </footer>
    </div>

);
}`}

</CodeSnippet>

The layout component demonstrates several key patterns: a sticky header with conditional styling based on the current route, an animated mobile menu with staggered transitions, and a flexbox layout that ensures the footer stays at the bottom. The mobile menu uses CSS transforms and opacity for smooth animations.

<CodeSnippet title="MDX Content Management" filename="content.ts">
{`// Dynamic content loading with TypeScript support
export function getIdeas() {
  const ideas = import.meta.glob('../content/ideas/*.mdx', { eager: true });
  
  return Object.entries(ideas)
    .map(([path, module]) => ({
      slug: path.replace('../content/ideas/', '').replace('.mdx', ''),
      title: module.frontmatter.title,
      date: module.frontmatter.date,
      excerpt: module.frontmatter.excerpt,
    }))
    .sort((a, b) => new Date(b.date) - new Date(a.date));
}

// Route loader for individual posts
export async function loader({ params }) {
const { slug } = params;
const content = await import(\`../content/ideas/\${slug}.mdx\`);

return {
content: content.default,
frontmatter: content.frontmatter
};
}`}

</CodeSnippet>

This content management system uses <ShinyLink href="https://vitejs.dev">Vite</ShinyLink>'s `import.meta.glob` to automatically discover and import <ShinyLink href="https://mdxjs.com">MDX</ShinyLink> files at build time. The frontmatter is extracted for metadata like titles and dates, while the content is dynamically loaded in route loaders. This approach eliminates the need for a traditional CMS while maintaining type safety.

<CodeSnippet title="Vite Configuration" filename="vite.config.ts">
  {`// Modern build setup with MDX and ngrok support
export default defineConfig({
  plugins: [
    tailwindcss(), 
    mdx({
      jsxImportSource: "react",
      providerImportSource: "@mdx-js/react",
      remarkPlugins: [
        remarkFrontmatter,
        [remarkMdxFrontmatter, { name: "frontmatter" }]
      ],
    }),
    reactRouter(), 
    tsconfigPaths()
  ],
  server: {
    allowedHosts: [
      "localhost",
      ".ngrok-free.app", // Support for ngrok tunneling
      ".ngrok.io"
    ]
  }
});`}
</CodeSnippet>

The <ShinyLink href="https://vitejs.dev">Vite</ShinyLink> configuration showcases the modern build pipeline. The <ShinyLink href="https://mdxjs.com">MDX</ShinyLink> plugin handles frontmatter extraction and JSX compilation, while the ngrok allowedHosts configuration enables easy local development with external access for testing on mobile devices.

<CodeSnippet title="Animated Components with React Bits" filename="HomePage.tsx">
{`// LetterGlitch background with DecryptedText header
import { LetterGlitch, DecryptedText } from "../components/react-bits";

export default function Home() {
  return (
    <div className="bg-white text-black overflow-x-hidden">
      {/* Full-width animated background */}
      <div className="relative overflow-hidden">
        <div className="absolute inset-0 z-0">
          <LetterGlitch
            glitchColors={["#f0f0f0", "#f4f4f4", "#eeeeee"]}
            glitchSpeed={500}
            smooth={true}
            outerVignette={false}
            centerVignette={false}
          />
        </div>

        <div className="container mx-auto px-6 relative z-10">
          <h1 className="text-5xl sm:text-6xl lg:text-7xl font-extralight">
            <DecryptedText
              text="Hello, I'm Vivek"
              animateOn="view"
              revealDirection="start"
              speed={100}
            />
          </h1>
        </div>
      </div>
    </div>

);
}`}

</CodeSnippet>

The home page demonstrates layered animations using React Bits components. The LetterGlitch provides a subtle animated background that doesn't interfere with readability, while DecryptedText creates an engaging reveal effect for the main heading. The `overflow-x-hidden` class prevents horizontal scrolling issues on mobile.

<CodeSnippet title="Reusable Page Header Component" filename="PageHeader.tsx">
{`// Simple, consistent page headers across all routes
interface PageHeaderProps {
  title: string;
}

export function PageHeader({ title }: PageHeaderProps) {
  return (
    <div className="mb-16">
      <h1 className="text-4xl font-light">{title}</h1>
    </div>
  );
}

// Usage in route components
import { PageHeader } from "../components/layouts";

export default function About() {
  return (
    <div className="bg-white text-black">
      <div className="container mx-auto px-6 py-20">
        <PageHeader title="About" />
        {/* Page content */}
      </div>
    </div>
  );
}`}
</CodeSnippet>

This demonstrates the DRY principle applied to UI components. Rather than repeating header markup across pages, a single reusable component ensures consistency. The interface provides type safety while keeping the API minimal. This pattern makes global design changes simple to implement.

<CodeSnippet title="Arrow Animation Micro-Interaction" filename="LinkAnimations.tsx">
{`// Consistent hover animations across all arrow links
<Link 
  to="/projects"
  className="group px-4 py-1 text-sm border border-gray-300 rounded-full hover:bg-gray-50 transition-colors"
>
  View all <span className="inline-block transition-transform group-hover:translate-x-1">â†’</span>
</Link>

<Link 
  to={\`/ideas/\${post.slug}\`}
  className="group text-sm text-gray-600 hover:text-black transition-colors inline-block"
>
  View Article <span className="inline-block transition-transform group-hover:translate-x-1">â†’</span>
</Link>

// Applied consistently across home sections, project cards, and article links`}

</CodeSnippet>

These micro-interactions add polish without overwhelming the user. The arrow translate animation provides immediate feedback on hover, while the group/group-hover pattern ensures the animation only affects the arrow, not the entire link. This creates a cohesive experience across all navigation elements.

<CodeSnippet title="Canvas Confetti Integration" filename="Newsletter.tsx">
{`// Adding celebration effects with canvas-confetti
import confetti from "canvas-confetti";

export function Newsletter() {
  const [showSuccessModal, setShowSuccessModal] = useState(false);

// Trigger confetti when success modal opens
useEffect(() => {
if (showSuccessModal) {
confetti({
particleCount: 50,
spread: 60,
origin: { y: 0.6 },
disableForReducedMotion: true,
colors: ['#FFD700', '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57']
});
}
}, [showSuccessModal]);

return (
<Modal
isOpen={showSuccessModal}
onClose={() => setShowSuccessModal(false)}
title="Successfully Subscribed! ðŸŽ‰" >
{/* Modal content */}
</Modal>
);
}`}

</CodeSnippet>

The newsletter subscription includes a delightful confetti effect using <ShinyLink href="https://github.com/catdad/canvas-confetti">canvas-confetti</ShinyLink>. When users successfully subscribe, the celebration animation enhances the positive feedback while respecting accessibility preferences through the `disableForReducedMotion` option. The confetti colors are carefully chosen to match the festive party emoji aesthetic, creating a cohesive celebratory experience.

## Development Experience

The development setup prioritizes fast feedback loops and maintainability:

- **Hot module replacement** for instant updates during development
- **TypeScript** throughout for type safety and better IDE support
- **Consistent code organization** making features easy to locate and modify
- **Component-driven development** enabling rapid UI iteration

## Performance Considerations

The site achieves excellent Core Web Vitals through several optimizations:

- Server-side rendering for fast initial page loads
- Minimal JavaScript bundle sizes through code splitting
- Optimized images and lazy loading
- Efficient CSS delivery via Tailwind's purging

This architecture strikes a balance between developer experience and user performance, making it both enjoyable to work with and fast for end users.

## Deployment with Google Cloud Run

The application is deployed on <ShinyLink href="https://cloud.google.com/run">Google Cloud Run</ShinyLink>, Google's fully managed serverless container platform. Cloud Run provides the perfect balance of simplicity, scalability, and cost-effectiveness for modern web applications.

### Why Google Cloud Run?

Cloud Run offers several compelling advantages for this portfolio site:

- **Serverless Architecture**: No servers to manage or maintain - Cloud Run handles all infrastructure automatically
- **Scale to Zero**: When there's no traffic, the service scales down to zero instances, meaning you only pay for actual usage
- **Automatic Scaling**: Seamlessly handles traffic spikes by automatically scaling up to handle thousands of concurrent requests
- **Container-Based**: Deploy any containerized application without vendor lock-in
- **Built-in HTTPS**: Automatic SSL certificates and secure connections out of the box
- **Global Load Balancing**: Requests are automatically routed to the nearest region for optimal performance

### The Deployment Architecture

The deployment pipeline uses a multi-stage approach for optimal efficiency:

<CodeSnippet title="Multi-Stage Docker Build" filename="Dockerfile">
{`# Build stage - compile and build the application
FROM node:20-alpine AS builder
WORKDIR /app

# Install dependencies with legacy peer deps for React 19 compatibility
COPY package*.json ./
RUN npm ci --legacy-peer-deps

# Build the application
COPY . .
RUN npm run build

# Production stage - lightweight runtime image
FROM node:20-alpine

# Add signal handling for graceful shutdowns
RUN apk add --no-cache dumb-init

# Create non-root user for security
RUN addgroup -g 1001 -S nodejs && \\
    adduser -S nodejs -u 1001

# Copy only production dependencies and built files
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production --legacy-peer-deps

# Copy built application from builder stage
COPY --from=builder --chown=nodejs:nodejs /app/build ./build

# Run as non-root user
USER nodejs

# Cloud Run automatically sets the PORT environment variable
ENV PORT=3000

# Start with proper signal handling
ENTRYPOINT ["dumb-init", "--"]
CMD ["sh", "scripts/start.sh"]`}
</CodeSnippet>

This multi-stage build approach reduces the final image size by over 60%, keeping only the production dependencies and compiled assets. The use of Alpine Linux further minimizes the footprint, while `dumb-init` ensures proper signal handling for graceful shutdowns in the containerized environment.

### Automated CI/CD with Cloud Build

The deployment process is fully automated using Google Cloud Build, triggered on every push to the main branch:

<CodeSnippet title="Cloud Build Configuration" filename="cloudbuild.yaml">
{`steps:
  # Build Docker image with versioning
  - name: 'gcr.io/cloud-builders/docker'
    args: ['build', '-t', 'gcr.io/$PROJECT_ID/website:$BUILD_ID', 
           '-t', 'gcr.io/$PROJECT_ID/website:latest', '.']
  
  # Push to Google Container Registry
  - name: 'gcr.io/cloud-builders/docker'
    args: ['push', 'gcr.io/$PROJECT_ID/website:$BUILD_ID']
  
  # Deploy to Cloud Run with optimized settings
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    entrypoint: gcloud
    args:
      - 'run'
      - 'deploy'
      - 'website'
      - '--image=gcr.io/$PROJECT_ID/website:$BUILD_ID'
      - '--region=us-central1'
      - '--platform=managed'
      - '--allow-unauthenticated'  # Public website access
      - '--memory=512Mi'            # Optimized memory allocation
      - '--cpu=1'                   # Single CPU for cost efficiency
      - '--max-instances=10'        # Auto-scale up to 10 instances
      - '--min-instances=0'         # Scale to zero when idle
      - '--set-env-vars=NODE_ENV=production'
      - '--update-secrets=SUPABASE_URL=supabase-url:latest'`}
</CodeSnippet>

This configuration provides:
- **Automatic builds** on code changes
- **Versioned deployments** with rollback capability
- **Zero-downtime updates** through Cloud Run's traffic management
- **Secret management** for sensitive environment variables
- **Cost optimization** through scale-to-zero and resource limits

### Setting Up Cloud Run Deployment

Here's the complete process I used to deploy this application:

1. **Project Setup**: Created a new Google Cloud project and enabled the required APIs:
   ```bash
   gcloud services enable cloudbuild.googleapis.com
   gcloud services enable run.googleapis.com
   gcloud services enable containerregistry.googleapis.com
   ```

2. **Container Registry Configuration**: Configured Docker authentication for pushing images:
   ```bash
   gcloud auth configure-docker
   ```

3. **Initial Deployment**: The first deployment was done manually to verify everything worked:
   ```bash
   # Build the container locally
   docker build -t gcr.io/PROJECT_ID/website:latest .
   
   # Push to Container Registry
   docker push gcr.io/PROJECT_ID/website:latest
   
   # Deploy to Cloud Run
   gcloud run deploy website \
     --image gcr.io/PROJECT_ID/website:latest \
     --region us-central1 \
     --allow-unauthenticated
   ```

4. **Automated Pipeline**: Set up Cloud Build triggers to automatically deploy on pushes to main branch

5. **Custom Domain**: Mapped the custom domain through Cloud Run's domain mapping feature:
   ```bash
   gcloud run domain-mappings create \
     --service website \
     --domain vivekmahendra.com \
     --region us-central1
   ```

### Performance and Cost Benefits

The Cloud Run deployment delivers impressive results:

- **Cold starts** under 1 second thanks to the optimized container
- **Response times** averaging 50-100ms for cached content
- **Monthly costs** under $5 for typical portfolio traffic
- **99.95% uptime** SLA with Google's infrastructure
- **Automatic scaling** handling traffic spikes seamlessly

### Monitoring and Observability

Cloud Run provides built-in monitoring through Google Cloud Console:

- Real-time request metrics and latency tracking
- Automatic error reporting and alerting
- Container CPU and memory utilization graphs
- Detailed request logs for debugging

The combination of React Router v7's server-side rendering and Cloud Run's edge locations ensures fast load times globally, while the scale-to-zero capability keeps hosting costs minimal for a portfolio site with variable traffic patterns.
